# typescript

## any unknown never
  1. any
      没有任何类型限制。该类型的变量可以赋予任何类型的值。
      any是所有其他类型的全集，包含了一切可能的类型。

  2. unknown
    unknown表示类型不确定，可以是任意类型

    unknown类型的变量不能直接赋值给其他变量（除了any和unknown类型的以外）。且不能直接调用unknown类型变量的属性和方法。
    unknown类型变量只支持比较运算、取反运算、typeof 、instanceof运算符。
    要使用unknown类型变量进行其他运算，需对其进行【类型缩小】--即缩小unknown变量的类型范围，以确保其不会出错。
  3. never
    never类型，即该类型为空，不包含任何值（空集）。
    其主要用在一些类型运算中，以确保类型运算的完整性。
    另外，不可能有返回值的一些函数，其返回值类型可写为never。
    【注】never类型变量可以赋值给任意其他类型变量。（空集是任意集合的子集）。

    typescript的【顶层类型】：any unknown，
                【底层类型】：never

## string boolean number bigint symbol object undefined null 

  注意区分【包装对象类型】（如String\Number\Boolean\Object等）和【字面量类型】

## 数组、元组

元组--ts特有类型，它表示成员类型可以自由设置的数组，即数组各个成员类型可以不同，元组必须声明每个成员的类型。


## interface type

1. interface 
  interface为对象模板，可看作一种类型约定，中文以为“接口”。使用某个模板对象，就拥有了指定类型结构。

  interface 可以使用extends关键字继承其他interface;

  interface 允许多重继承(用,隔开)

  interface可继承type定义的类型结构

  interface 可继承类

  【注】type 定义的对象类型，可以使用 & | 进行类型的拓展与合并 

2. interface 与 type的异同
  interface命令与type命令作用类似，都可以表示对象类型。
  很多对象类型即可以用 interface 表示，也可以用 type 表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。
  它们的相似之处，首先表现在都能为对象类型起名。
  （1）type能够表示非对象类型，而interface只能表示对象类型（包括数组、函数等）。
  （2）interface可以继承其他类型，type不支持继承。
  （3）同名interface会自动合并，同名type则会报错。
  （4）interface不能包含属性映射（mapping），type可以
  （5）this关键字只能用于interface
  （6）type 可以扩展原始数据类型，interface 不行。
  （7）interface无法表达某些复杂类型（比如交叉类型和联合类型），但是type可以。

  综上所述，如果有复杂的类型运算，那么没有其他选择只能使用type；一般情况下，interface灵活性比较高，便于扩充类型或自动合并，建议优先使用。



  ## class

  interface接口或type别名可以用对象的形式，为class指定一组检查条件。class 使用implements关键字，表示该类满足当前的条件限制。
  类可以定义接口没有声明的方法和属性。
  implements关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。
  类可以实现多个接口（其实是接受多重限制），每个接口之间使用逗号分隔。
  TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。
  要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。
  类的自身类型就是一个构造函数，可以单独定义一个接口来表示。

  类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。
  注意，extends关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。

  ## ts 泛型
  有些时候，函数返回值的类型与参数类型是相关的。泛型的特点就是带有“类型参数”（type parameter）。
  【注意】
    1. 尽量少用泛型。（泛型灵活但会增加代码复杂性）
    2. 泛型的类型参数越少越好。（多一个类型参数，多一道转换步骤，增加了复杂性）
    3. 类型参数出现的次数至少两次以上。（只出现一次的类型参数使用泛型是没有必要的）
    4. 泛型可以嵌套。（泛型参数可以是另外一个泛型）

## enum
  ts 的 Enum 结构，用来将相关常量放在一个容器里面，方便使用。
  第一个成员的值默认为整数0，第二个为1，第二个为2，以此类推。
  Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。
  Enum 作为类型有一个缺点，就是输入任何数值都不报错。
  可以为 Enum 成员显式赋值。
  keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。

  数值 Enum 存在反向映射，即可以通过成员值获得成员名。



## 类型断言
TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。

1. as 

【注】不要滥用类型断言，因为类型断言会让错误的代码通过编译。

类型断言的一大用处是，指定 unknown 类型的变量的具体类型。

类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。

某个类型要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。

2. as const 

如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。
即const有更强的限定作用，可以缩小变量的类型范围。

总之，as const会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。

【注】as const断言只能用于字面量，不能用于变量以及表达式。
      as const 可写成前置的形式，也可用于对象
```typescript
expr as const 
<const>expr
```

as const会将数组变成只读元组，所以很适合用于函数的 rest 参数

3. 非空断言
对于那些可能为空的变量（即可能等于undefined或null），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号!

4. 断言函数
断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。
【注意】TypeScript 并不会检查断言与实际的类型检查是否一致。
另外，断言函数的asserts语句等同于void类型，所以如果返回除了undefined和null以外的值，都会报错。

## 模块
任何包含import 或者export语句的文件，就是一个模块。相应的，文件不包含export语句的则属于全局脚本。

## namespace命名空间
它出现在 ES 模块诞生之前，作为 TypeScript 自己的模块格式而发明的。但是，自从有了 ES 模块，官方已经不推荐使用 namespace 了。

## 装饰器
装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。

装饰器特征：
1. 前缀为@，后边跟着一个表达式
2. 表达式必须为函数（或执行后返回的是一个函数）
3. 这个函数接受所修饰对象的一些相关值作为参数
4. 这个函数要么不返回值，要么返回一个新对象替换所修饰的对象。

