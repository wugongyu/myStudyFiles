# VUE3

## 一、 框架设计的各项权衡

### 声明式 与 命令式框架

  命令式框架更注重**过程**，而声明式框架更注重**结果**，它会将具体实现过程封装起来。
  比如**vue.js就是声明式框架**，其内部的实现一定是命令式的，而暴露给用户的则是声明式的。

### 性能与维护性

  声明式的代码性能**不优于**命令式的代码。
  因为框架本身就是**封装了命令式的代码才实现面向用户的声明式**。
  但声明式代码的**维护性更强**， 因为命令式代码需要维护的是**整个实现的过程**， 而声明式代码内部封装好之后，后续需要维护的则是暴露给用户的一些方法等。

  命令式代码的更新性能消耗 = 直接修改的性能消耗；
  声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。

  【框架设计】：在提高可维护性的同时，实现最小的性能消耗。

  虚拟DOM则是为了最小化找出差异的性能消耗而出现的。

- 利用innerHTML创建页面的性能 = HTML字符串拼接的计算量+innerHTML的DOM计算量
  可能需要全量创建新的DOM元素进行更新

- 利用虚拟DOM创建页面的性能 = 创建js对象的计算量（对真实DOM的描述） + 创建真实DOM的计算量
  进行差量创建与更新

  【性能比较】
  innerHTML（模板）: 心智负担中等，性能差
  虚拟DOM：心智负担小，可维护性强，性能不错
  原生JS（利用createElement等方法）：心智负担大，可维护性差，性能强

### 运行时，编译时，编译运行时框架

- 纯运行时
  用户直接提供数据对象而无需编译

- 纯编译时
  将HTML字符串直接编译成可执行的js命令式代码

- 编译 + 运行时
  用户可以提供HTML字符串，我们将其编译成数据对象，再交给运行时处理。
  有编译步骤，可以分析用户提供的内容。

  【vue3是 运行时 + 编译时的架构】

## 二、 框架设计的核心要素

1. 提供友好的警告信息
2. 利用tree-shaking排除dead-code以实现框架的打包体积最小化
3. 满足不同需求场景下的框架的输出产物
4. 出于灵活性与兼容性的考虑，框架可提供多种能力或功能（如VUE3向下兼容VUE2）
5. 良好的框架错误处理

## 三、 vue3的设计思想

### 渲染器与编译器

渲染器与编译器是vue.js的核心组成部分。

- 虚拟DOM
  用js对象来描述真实的DOM结构
  例如：

  ```js
  const vnode = {
    tag: 'div',
    prop: {
      onClick: () => {}
    },
    children: {}
  }

  ```

- 渲染器
  把虚拟DOM对象渲染成真实DOM对象。

  - 渲染器实现步骤
  创建：
  1. 根据虚拟节点（vnode）对象创建DOM元素
  2. 为DOM元素添加属性和事件
  3. 处理children

  更新
  需要精确的找到虚拟节点（vnode）对象的变更点并只更新变更的内容。

- 组件的本质
  组件其实就是一组虚拟DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象，但这个对象里面必须要有一个函数用来产出组件所需要渲染的虚拟DOM。

- 编译器
  编译器作用为将模板编译为渲染函数。
  例如vue文件中

  ```vue
  <template>
    <div @click="handler">
      click me
    </div>
  </template>
  <script>
  export default{
    data(){},
    methods: {
      handler() {}
    }
  }
  </script>
  ```

  编译器会把template里边的模块内容编译成渲染函数并添加到script标签里的组件对象上，最终在浏览器上运行的代码即为:

  ```js
  export default{
    data(){},
    methods: {
      handler() {}
    },
    render() {
      return h('div', { onClick: handler }, 'click me')
    },
  }
  ```

- vue中的渲染器与编译器
  编译器将模板中的内容编译成渲染函数，然后渲染器将渲染函数中返回的虚拟DOM渲染为真实DOM，当发生更新时，渲染器自行寻找变更点，并只更新变化的内容。

## 四、 vue3的响应式--响应系统的概念与实现

### 副作用函数effect

所谓的副作用函数，就是该函数的执行会直接或间接影响到其他函数的执行，因而产生了一定的副作用影响。
例如一个函数修改了全局变量，产生了副作用影响。

在 Vue 3 中，副作用函数（Effect Function）通常指的是那些依赖于响应式数据并在数据变化时重新执行的函数。

### 响应式数据

在一个副作用函数中读取了某个对象的属性，当对象的属性发生变化的时候，该副作用函数会重新执行，则该对象为响应式数据。

### 响应式系统的实现原理

  拦截一个对象的读取与设置操作，当读取对象字段的时候，将副作用函数存储至一个“桶”中，然后返回属性值；当设置对象字段的时候，先更新对象字段数据，然后将副作用函数从桶中取出并执行。

  其中有三个角色：

  1. 被操作的代理对象target
  2. 被操作的字段名key
  3. 使用effect函数注册的副作用函数effectFn

  三个角色有着树形结构的关系
  target -> key -> effectFn

  为使得副作用函数与被操作的目标字段建立起明确的关系，具体实现为使用WeakMap代替Map来作为存储副作用函数的“桶”的数据结构。

  其中WeakMap的键是原始对象target, WeakMap的值是一个Map实例，Map的键是原始对象的字段名key，Map的值是副作用函数组成的Set集合（即key的依赖集合）。

- 【注意】为何使用WeakMap作为存储副作用函数的数据结构
  WeakMap对key是弱引用，不影响垃圾回收器的工作。一旦key被垃圾回收器回收，那对应的键和值就访问不到了。
  所以WeakMap经常用于存储那些只有当key所引用的对象存在时（没有被回收）才有价值的信息。

### computed与watch

  在vue3中，computed与watch的实现本质上都是利用的副作用函数effect。

## 五、 非原始值的相应方案

### proxy 与reflect

- Proxy
  Proxy可以创建一个**代理对象**，它能够实现对**其他对象**的代理。

  **代理**指的是对一个对象的**基本语义**的代理，它允许我们**拦截并重新定义**对一个对象的基本操作。
  
  类似**读取，设置对象属性值**等操作属于基本语义的操作。

  函数也属于对象，**调用函数也是对一个对象的基本操作**。

  在proxy中是用get方法拦截对象的读取操作，是用set方法拦截对象的设置操作，是用apply方法拦截函数的调用操作。

  【注意】proxy只能够拦截对一个对象的基本操作。

- Reflect
  Reflect为内置的js对象，它是不可构造的；
  Reflect中所有的属性与方法都是静态的；
  Reflect内部封装了一系列对对象的底层操作；
  Reflect成员方法就是Proxy处理对象的默认实现；
  任何在Proxy拦截器中能找到的方法，都能在Reflect中找到同名方法。

  - Reflect作用
  
  ```js
  // 设置1
  let obj = { name: "yq" };
  obj.name = "yqcoder";
  console.log(obj); // { name: 'yqcoder' }

  // 设置2
  let obj = { name: "yq" };
  Reflect.set(obj, "name", "yqcoder");
  console.log(obj); // { name: 'yqcoder' }
  ```

  以上两种属性设置方法的效果是一样的，区别在于，通过语法或者一些 API 去调用对象的内部方法的话，它会经过一些规则和步骤，在这些规则和步骤当中，有一步是在调用这个内部方法。如果不希望有这些额外步骤存在，那就需要直接去调用对象的基本方法了，这时就可以使用Reflect。

  而且，对于Reflect.get方法可以传入第三个参数从而更改对象的this指向。

- 关于对象Object的代理

  代理对象的本质是，通过查阅规范并找到可拦截的基本操作的方法。而对于复合操作，则是查阅规范看其依赖的基本操作是那些，然后对基本操作进行拦截处理从而间接地处理复合操作。

  1. 访问对象属性 obj.foo
  通过get拦截函数实现。

  2. 判断对象或原型上是否存在给定的key: key in obj
  通过规范可知，可通过has拦截函数实现对in操作符的代理。

  3. for...in 循环遍历对象
  使用ownKeys拦截函数拦截Reflect.ownKeys操作，从而间接拦截for...in循环

  注意区分遍历对象的目的是修改对象属性值还是只是读取属性值。
  4. 删除属性操作 delete p.foo
  使用deleteProperty拦截删除操作，并调用Reflect.deleteProperty来完成属性的删除工作。

- 关于数组的代理
  数组对象除了 [[DefineOwnProperty]] 这个内部方法
  之外，其他内部方法的逻辑都与常规对象相同。

  【重点】在于数组读取|设置时会直接或间接读取length属性，所以在读取或设置时需做出拦截响应length相关操作
  此外，需要重写数组的一些方法（数组查找方法、隐式修改数组长度的一些数组原型方法）以解决数据改动无法响应以及一些不必要的响应的问题
  在不同的副作⽤函数内对同⼀个数组执⾏数组push,pop等间接改变数组长度的⽅法，会导致多个副作⽤函数之间循环调⽤，最终导致
  调⽤栈溢出，解决方法为标记一个全局变量shouldTrack，当这些⽅法间接读取 length 属性值时，我们会先将
  shouldTrack 的值设置为 false，即禁⽌追踪。这样就可以断开
  length 属性与副作⽤函数之间的响应联系，从⽽避免循环调⽤导致
  的调⽤栈溢出。

- 关于Set和Map等集合类型数据的代理

  1. Set属性与方法
  size, add, clear, delete, has, keys, values, entries, foreach

  2. Map属性与方法
  size, set, get, clear, delete, has, keys, values, entries, foreach

Set和Map数据类型的操作方法相似，不同的是，Set通过add(value)添加元素，
Map通过set(key, value)添加键值对，而且Map可以通过get(key)获取对应key的值。

  【重点】对于集合类型数据，对其特定的属性以及一些方法进行自定义拦截|重写，从而实现响应式数据

## 六、原始值的响应式方案

  由于proxy的代理目标对象必须是非原始值，故要拦截对原始值的操作，解决方法是：使用一个非原始值去“包裹”原始值。

## 七、渲染器

### 概念

- 渲染器（renderer）
  【注意】区分renderer与render（渲染）
  渲染器是更加宽泛的概念，它包含渲染。
  作用：将虚拟DOM（vdom）渲染为特定平台上的真实元素，
  渲染器不仅可以用来渲染，还可以用来激活已有的DOM元素（同构渲染时）

  渲染器将虚拟DOM渲染为真实DOM的过程称为挂载（mount）。

  渲染器接受一个挂载点作为参数，挂载点 — — 即一个dom元素，也就是容器（container）元素，
  渲染器把内容渲染到容器中。

  【打补丁】
  渲染器会使用newVnode与上一次的oldVnode进行对比，试图找到并更新变更点，这个过程叫做打补丁。

- 响应系统和渲染器的关系
  利用响应系统的能力，自动调用渲染器完成页面的更新与渲染。

## 八、挂载与更新

### HTML attributes 与 DOM properties

**HTML attributes**即定义在HTML标签上的属性

在浏览器解析完html代码之后，会创建与之相符的**DOM元素对象**。

**DOM properties**即DOM元素对象下的属性。

DOM元素对象上与与HTML 标签上同名的属性，但不总是一模一样的。

HTML Attributes 与 DOM Properties 具有相同
名称（即 id）的属性看作直接映射。

HTML标签属性的作用是设置与之对应的DOM元素属性的初始值。

但一个html标签属性可能和与之对应的DOM元素上的多个属性相关联。
比如value="test"与el.value、el.defaultValue相关联。

### 卸载

根据vnode对象获取与其相关联的真实DOM对象，然后使用原生DOM操作方法移除该DOM元素
注意：将真实DOM元素绑定在vnode对象上，即vnode.el = el，使得vnode与真实DOM建立了联系，从而在卸载阶段vnode可以获取到真实DOM。

### 事件的处理

如何将虚拟节点上描述的事件添加到真实DOM上： 使用addEventListener来进行事件绑定与监听。

事件更新方式：
    一般思路方案：移除之前添加绑定的事件处理函数，再将新的事件处理函数绑定到DOM元素上。
    性能优化方案：在绑定事件时，绑定一个伪造的事件处理函数invoker，并把真正的事件处理函数设置为invoker.value;
                  在更新事件时，不再调用removeEventListener来移除绑定事件，只需更新invoker.value的值即可。
                  【注】使用伪造的事件处理函数不仅提高了性能，还解决了事件更新与事件冒泡之间的影响问题。

### 事件冒泡与更新时机

如何处理事件与更新时机的问题：解决⽅案是，利
⽤事件处理函数被绑定到 DOM 元素的时间与事件触发时间之间的差
异。我们需要屏蔽所有绑定时间晚于事件触发时间的事件处理函数的
执⾏。

## 九、简单diff算法

当新旧vnode的子节点均为一组节点时，为了**减小更新节点的性能开销**，通常使用diff算法来比较操作两组节点。

### DOM的复用与key的作用

vnode的key就像虚拟节点的身份证，只要vnode的type数组和key属性相同，就认为两个虚拟节点是相同的，即可以进行DOM复用。

**所谓的复用并不代表不用更新**，通过遍历新vnode，通过新vnode的key获取到旧vnode中具有相同key的节点，然后对新旧两节点进行差量更新。

### 找到需移动的元素并移动

- 寻找方式：
  遍历新vnode子节点，将子节点在旧vnode子节点中的索引定义为：在旧 children 中寻找具有相同 key 值节点的过程中，遇到的**最⼤索引值**。如果在后续寻找的过程中，**存在索引值⽐当前遇到的最⼤索引值还要⼩的节点**，则意味着该节点**需要移动**。 ⽤ lastIndex 变量存储整个寻找过程中遇到的最⼤索引值。

- 移动方式：
  注意，**新vnode子节点的顺序其实就是更新后真实 DOM 节点应有的顺序**。
  需要获取当前 newVNode 节点的前⼀个虚拟节点，然后使⽤ insert 函数完成节点的移动，其中 insert 函数依赖浏览器原⽣的 insertBefore 函数。

### 添加新元素与移除不存在的元素

- 添加新元素
  为了将新节点挂载到正确位置，需要先获取锚点元素：找到当前新newVNode 的前⼀个虚拟节点，即**prevVNode，如果存在，则使⽤它对应的真实 DOM 的下⼀个兄弟节点作为锚点元素；如果不存在，则说明即将挂载的 newVNode 节点是容器元素的第⼀个⼦节点，此时应该使⽤容器元素的 container.firstChild 作为锚点元素**。最后，将锚点元素 anchor 作为 挂载patch 函数的第四个参数，调⽤ patch 函数完成节点的挂载。

- 删除节点
遍历旧的⼀组⼦节点，然后去新的⼀组⼦节点中寻找具有相同 key 值的节点。如果找不到，则说明应该删除该节点。

## 十、双端DIFF算法

【注意】简单diff算法对于DOM元素的移动操作并不是最优解。

### 双端diff算法

双端diff算法是同时对新旧两组子节点的两个端点进行比较的算法。

#### 双端比较方式

  1. **定义索引变量等**
    新旧两组子节点oldChildren、newChildren
    先分别定义四个端点索引：
    let oldStartIdx = 0
    let oldEndIdx = oldChildren.length - 1
    let newStartIdx = 0
    let newEndIdx = newChildren.length - 1

  2. **循环比较处理**
    当新|旧节点组起始端点索引均小于等于终止端点索引，进行以下循环
      1. 旧新子节点组的第一个节点进行比较，若节点可复用，对新旧节点进行打补丁，但无需进行DOM移动操作，同时更新对应的端点索引；
      2. 旧新子节点组的最后一个节点进行比较，若节点可复用，对新旧节点进行打补丁，但无需进行DOM移动操作，同时更新对应的端点索引；
      3. 旧子节点组的第一个节点与新子节点组的最后一个节点进行比较，若节点可复用，进行节点差量更新，且进行DOM移动操作完成更新，同时更新对应的端点索引；
      4. 旧子节点组的最后一个节点但与新子节点组的第一个节点进行比较，若节点可复用，则进行节点差量更新，且进行DOM移动操作完成更新，同时更新对应的端点索引；

### 双端diff算法的优势

对于同样的例⼦，使⽤双端 Diff 算法相比于采⽤简单 Diff 算法，能够有效减少DOM 移动操作次数来完成更
新，从而提供了性能。

## 十一、快速diff算法

### 快速diff方式

  思路：先获取新旧两组节点中相同的前置节点与后置节点，由于它们在新旧两组⼦节点中
的相对位置不变，所以我们⽆须移动它们，但仍然需要在它们之间打补丁。

- 更新前置节点
  建立索引j，指向新旧两组节点的开头；开启while循环，向后遍历这两组⼦节点，
  直到遇到 key 值不同的节点为⽌。

- 更新后置节点
  建立两个索引 newEnd 和 oldEnd，分别指向新旧两组⼦节点中的最后⼀个节点；开启while循环，从后向前遍历两组子节点，
  直到遇到 key 值不同的节点为⽌。

- 处理新增节点与删除节点
  根据条件判断
  j > oldEnd && j <= newEnd  符合该条件说明新子节点组中存在遗留节点（j~newEnd范围的节点），且这些节点都是新增节点，因此需要挂载这些节点
  j > newEnd && j <= oldEnd  符合该条件说明旧子节点组中存在遗留节点（j~oldEnd范围的节点），因此需要卸载这些节点

- 部分未经处理节点
  构造数组source，⻓度等于新的⼀组⼦节点在经过预处理之后剩余未处理节点的数量，并且 source 中每个元素的初始值都是 -1。

  source数组用处：
  source 数组将⽤来存储新的⼀组⼦节点中的节点在旧的⼀组⼦节点中的位置索引（默认-1，即不存在于旧子节点中），后⾯将会使⽤它计算出⼀个**最⻓递增⼦序列**，并⽤于辅助完成 DOM 移动的操作，

### 总结

  快速 Diff 算法在实测中性能最优。它借鉴了⽂本 Diff 中的预处理思路，**先处理新旧两组⼦节点中相同的前置节点和相同的后置节点**。
  当前置节点和后置节点全部处理完毕后，如果⽆法简单地通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引
  关系，**构造出⼀个最⻓递增⼦序列**。**最⻓递增⼦序列所指向的节点即为不需要移动的节点**。

## 十二、组件化

### 组件

  将一个大的页面拆分为多个部分，每一个部分都可以作为单独的组件，这些组件共同组成完整的页面。
  从用户角度而言：一个有状态组件就是一个**选项对象**；
  从渲染器的内部实现来看：一个组件则是一个特殊类型的虚拟节点（vnode）；

  在描述组件的虚拟节点中，使用vnode.type来存储组件的选项对象。

  ```js
  const MyComponent = {
    name: 'MyComponent',
    // data函数定义组件自身的状态
    data: function() {
      return {
        text: 'test text'
      }
    },
    // 组件的渲染函数，其返回值必须为虚拟DOM对象
    render() {
      return {
        type: 'div',
        children: '我是文本内容'
      }
    }
  }
  ```

### 渲染组件

  **一个组件必须包含一个渲染函数**，即render函数，且该渲染函数**返回的应该是一个虚拟节点**。

### 组件状态

  组件中用data函数来定义组件自身的状态

  组件自更新原理： **使用reactive把data函数返回的状态数据变为响应式，同时使用effect函数将组件的渲染操作包装起来，从而实现组件的自更新**。

  更新优化： ⽆论对响应式数据进⾏多少次修改，副作⽤函数都只会重新执⾏⼀次。为此，需要实现⼀个**调度器**，当副作⽤函数需要重新执⾏时，不会⽴即执⾏它，⽽是将它**缓冲到⼀个微任务队列中**，等到执⾏栈清空后，再将它从微任务队列中取出并执⾏。有了缓存机制， 就有机会**对任务进⾏去重**，从⽽避免多次执⾏副作⽤函数带来的性能开销。

### 组件实例

  一个组件实例本质上就是一个对象，它包含组件有关的状态信息，例如组件的⽣命周期函数、组件渲
染的⼦树（subTree）、组件是否已经被挂载、组件⾃⾝的状态（data），等等。

### 组件的生命周期原理

从组件的选项对象中取得注册到组件上的⽣命周期函数，然后在合适的时机调⽤它们，这其实就是组件⽣命周期的实现原理。

### props

 ```js
  const MyComponent = {
    name: 'MyComponent',
    // data函数定义组件自身的状态
    data: function() {
      return {
        text: 'test text'
      }
    },
    props: { // 接受props
      title: String,
    },
    // 组件的渲染函数，其返回值必须为虚拟DOM对象
    render() {
      return {
        type: 'div',
        children: `我是文本内容${this.title}`, // 访问props数据
      }
    }
  }

  const vnode = {
    type: MyComponent,
    props: {
      title: 'a big title',
    }
  }
  ```

  【注意】我们需要关注的是：
    为组件传递的 props 数据，即vnode.props
    在组件选项对象内定义的props对象，即MyComponent.props
    把父组件自更新引起的子组件的更新叫做**子组件的被动更新**。

### setup

  setup 函数主要⽤于配合组合式 API，为⽤户提供⼀个地⽅，**⽤于建⽴组合逻辑、创建响应式数据、创建通⽤函数、注册⽣命周期钩⼦等**能⼒。在组件的整个⽣命周期中，**setup 函数只会在被挂载时执⾏⼀次**，它的返回值可以有两种情况。
  (1) 返回⼀个函数，该函数将作为组件的 render 函数；
  (2) 返回⼀个对象，该对象中包含的数据将暴露给模板使⽤。

### 组件事件与emit

  emit ⽤来发射（触发）组件的⾃定义事件。
  发射⾃定义事件的本质就是根据事件名称去props 数据对象中寻找对应的事件处理函数并执⾏。

### 插槽slot
  
  组件的插槽指组件会预留⼀个槽位，该槽位具体要渲染的内容由⽤户插⼊。
  组件模板中的插槽内容会被编译为插槽函数，⽽插槽函数的返回值就是具体的插槽内容。

  渲染插槽内容的过程，就是调⽤插槽函数并渲染由其返回的内容的过程。

### 注册生命周期钩子函数

   Vue.js 3 中，有⼀部分组合式 API 是⽤来注册⽣命周期钩⼦函数的，例如 onMounted、onUpdated 等。
   注意这些注册方法只能在setup函数中调用

## 十三、异步组件与函数式组件

- 异步组件
  **以异步的方式加载并渲染一个组件**，在代码分割与服务端下发组件等场景中尤为重要。

  ```vue
  <template>
    <AsyncComp />
  </template>
  <script>
    export default {
      components: {
        // 使⽤ defineAsyncComponent 定义⼀个异步组件，它接收⼀个加载器作为参数
          AsyncComp: defineAsyncComponent(() => import('CompA'))
        }
      }
  </script>
  ```

  【异步组件】
  - 允许⽤户指定加载出错时要渲染的组件。
  - 允许⽤户指定 Loading 组件，以及展⽰该组件的延迟时间。
  - 允许⽤户设置加载组件的超时时⻓。
  - 组件加载失败时，为⽤户提供重试的能⼒。

- 函数式组件
  使用一个**普通函数定义组件**，并**使用该函数的返回值作为组件要渲染的内容**。
  函数式组件的特点：无状态，编写简单且直观。
  
  【注意】在 Vue.js3 中使⽤函数式组件，主要是因为它的简单性，⽽不是因为它的性能
  好。”这是因为在 Vue.js 3 中，即使是有状态组件，其初始化性能消耗也⾮常⼩。

  在⽤户接⼝层⾯，⼀个函数式组件就是⼀个返回虚拟 DOM 的函数。
  函数式组件没有⾃⾝状态，但它仍然可以接收由外部传⼊的props。

## 十四、vue的内建组件与模块

  Vue.js 中有⼏个⾮常重要的内建组件和模块：如KeepAlive 组件、Teleport 组件、Transition 组
件等。

### KeepAlive组件

- http协议中的KeepAlive
  一个http连接会在每次请求/响应结束后关闭，在下一次请求发生时重新建立一个http连接，频繁地销毁、创建连接会带来额外的性能开销。
  而keepAlive为http持久连接，它允许多个请求或响应公用一个tcp连接。

- vue的内建KeepAlive组件
  避免一个组件频繁的销毁与创建。

- KeepAlive的实现原理
  本质上是缓存管理，再加上特殊的挂载与卸载逻辑。

  将被 KeepAlive 的组件从原容器搬运到另外⼀个隐藏的容器中，实现“假卸载”。当被搬运到隐藏容器中的组件需要再次被“挂载”时，不能执⾏真正的挂载逻辑，⽽应该把该组件从隐藏容器中再搬运到原容器。这个过程对应到组件的⽣命周期，其实就是 activated 和 deactivated。

  **KeepAlive 组件与渲染器的结合⾮常深**。

### Teleport （vue3新增）

  通常情况下，将虚拟DOM渲染为真实DOM，真实DOM的层级结构与真实DOM的层级结构是保持一致的。
  但有时候需要将组件渲染到指定容器中，**Teleport组件则是可以将指定内容渲染到特定容器中，⽽不受 DOM 层级的限制**。

  与 KeepAlive 组件⼀样，Teleport 组件也**需要渲染器的底层⽀持**。

  【注意】要将 Teleport 组件的渲染逻辑从渲染器中分离出来，这样的好处是：避免代码膨胀，并且在打包时有利于进行tree shaking。

### Transition组件

  **Transition组件与渲染器的结合更加密切**。

  过渡效果本质上**是⼀个DOM元素在两种状态间的切换**，浏览器会根据过渡效果⾃⾏完成 DOM 元素的过渡。这⾥的过渡效果指的是持续时⻓、运动曲线、要过渡的属性等。

#### Transition组件的原理

- 当 DOM 元素被挂载时，将动效附加到该 DOM 元素上；
- 当 DOM 元素被卸载时，不要⽴即卸载 DOM 元素，⽽是等到附加到该 DOM 元素上的动效执⾏完成后再卸载它。

【注意】
transition组件本身不会渲染任何额外的内容，它只是通过默认的插槽读取过渡元素，并渲染需要过渡的元素；
transition组件的作用：即在过渡元素的虚拟节点上田间transition相关的钩子函数。

## 十五、编译器

### 编译器

**编译器**其实只是一段程序，它用来将“一种语言A”（源代码）翻译成“另外一种语言B”（目标代码）。

编译器将源代码翻译成目标代码的过程叫做**编译**。

**完整的编译过程包括**：词法分析、语法分析、语义分析，中间代码生成、优化、目标代码生成。

### vue.js模板编译器

vue.js的模板编译器的目标代码为渲染函数。

具体为：vue.js编译器对vue模板进行词法与语法分析，得到模板AST，然后将模板AST转化为 js AST，接着根据js AST生成js代码，即渲染函数。

AST: abstract syntax tree，抽象语法树，用来描述模板。

语义分析:

- 检查 v-else 指令是否存在相符的 v-if 指令。
- 分析属性值是否是静态的，是否是常量等。
- 插槽是否会引⽤上层作⽤域的变量。
- ...等等。

【AST】AST具有与模板同构的嵌套结构

- 不同类型的节点是通过节点的 type 属性进⾏区分的。例如标签节点的 type 值为 'Element'。
- 标签节点的⼦节点存储在其 children 数组中。
- 标签节点的属性节点和指令节点会存储在 props 数组中。
- 不同类型的节点会使⽤不同的对象属性进⾏描述。例如指令节点拥有 name 属性，⽤来表达指令的名称，⽽表达式节点拥有content 属性，⽤来描述表达式的内容。

Vue.js 模板编译器的基本结构和⼯作流
程，它主要由三个部分组成：

- ⽤来将模板字符串解析为模板 AST 的解析器（parser）；
- ⽤来将模板 AST 转换为 JavaScript AST 的转换器（transformer）；
- ⽤来根据 JavaScript AST ⽣成渲染函数代码的⽣成器（generator）。

### 解析器parser实现原理与状态机

#### 状态机

  有限状态自动机：指的是在**有限个状态**下，随着字符的输入，解析器会**自动地在不同状态间迁移**。

  有限状态⾃动机可以帮助我们完成对模板的标记化（tokenized），最终我们将得到⼀系列 Token。
  进而可以用这一系列token来构建一颗AST。

  【注意】**正则表达式的本质就是有限自动机**，在编写正则表达式的时候，实际上是在编写有限自动机。

### 构造AST

  模板标记化后获得一系列tokens, 根据tokens列表构建模板AST：
    维护一个栈elementStack，该栈用于维护元素间的父子关系。
    按顺序地扫描整个token列表，直至扫描完所有token。
    在这过程中，遇到一个开始标签节点，构造一个element类型的AST节点，将其压入栈；
    遇到一个结束标签节点，将当前栈顶的节点弹出。

### 模板AST的转换

  所谓 AST 的转换，指的是对 AST 进⾏⼀系列操作，将其转换为新的 AST 的过程。

  即模板AST转换为JavaScript AST。

  在这转换过程中，由于AST是树形结构，所以需要一个**深度优先的遍历算法**。

#### 转换函数中的上下文对象

  【上下文对象context】程序在某个范围内的全局变量。
  在转化函数中的context 可以看作 AST 转换函数程中的上下⽂数据。所有 AST 转换函数都可以通过 context 来共享数据。

#### 更理想的转换工作流

对节点的访问分为两个阶段，即进⼊阶段和退出阶段。当转换函数处于进⼊阶段时，它会先进⼊⽗节点，再进⼊⼦节点。⽽当转换函数处于退出阶段时，则会先退出⼦节点，再退出⽗节点。

**当把转换逻辑编写在转换函数的退出阶段时，不仅能够保证所有⼦节点全部处理完毕，还能够保证所有后续注册的转换函数执⾏完毕**。

### 代码生成

代码生成，即根据js ast生成渲染函数的代码。代码生成的本质是字符串的拼接艺术。
与 AST 转换⼀样，代码⽣成也需要上下⽂对象，该上下⽂对象⽤来维护代码⽣成过程中程序的运⾏状态。

## 十六、解析器

  一个完善的HTML解析器，遵循WHATWG中关于HTML的解析规范，其中包含了完整的错误处理和状态机的状态迁移流程，其中涉及一些特殊的状态：DATA、 CDATA、 RCDATA、 RAWTEXT。

- DATA模式
在DATA模式下，解析器遇到字符<时，会切换到标签开始状态，即**能够解析标签元素**；当解析到字符&时，会切换到字符引用状态，即**能够处理HTML字符实体**。

【注】HTML 实体是⼀段以字符 & 开始的⽂本内容

- RCDATA模式
在RCDATA状态下，解析器不能识别标签元素，但**仍然支持HTML实体字符**。

如： 在textarea标签内存在一个div标签，解析器不会把div解析为标签元素，而是当作普通文本处理，但可正常解析HTML实体字符。

- RAWTEXT模式
在RAWTEXT模式，解析器**不能识别标签元素，且不再支持HTML实体字符**。

例如： Vue.js 的单⽂件组件的解析器在遇到script标签时就会进⼊RAWTEXT 模式，这时它会把script标签内的内容全部作为普通⽂本处理。

- CDATA模式
该模式下，解析器把任何字符都作为普通字符，直到遇到CDATA的结束标志为止。

### 解析器的开始与停止

  解析器会在何时开启新的状态机，以及状态机会在何时停⽌？结论是：**当解析器遇到开始标签时，会将该标签压⼊⽗级节点栈，同时开启新的状态机。当解析器遇到结束标签，并且⽗级节点栈中存在与该标签同名的开始标签节点时，会停⽌当前正在运⾏的状态机**。

## 十七、编译优化

  编译优化指的是编译器**将模板编译为渲染函数的过程**中，尽可能多地**提取关键信息**，并**以此指导生成最优代码**的过程。

  不同框架优化策略不尽相同，但优化方向基本一致：**即尽可能地区分动态内容和静态内容，并针对不同的内容采用不同的优化策略**。

  传统diff算法存在很多无意义的对比操作，如果能够跳过这些无意义的操作，性能将会大幅提升。

  【为什么虚拟 DOM 会产⽣额外的性能开销呢？】根本原因在于，渲染器在运⾏时得不到⾜够的信息。**传统 Diff 算法⽆法利⽤编译时提取到的任何关键信息**（无法区分动态内容和静态内容），这导致渲染器在运⾏时不可能去做相关的优化。⽽ **Vue.js 3 的编译器会将编译时得到的关键信息“附着”在它⽣成的虚拟 DOM 上**，这些信息会通过虚拟 DOM 传递给渲染器。最终，**渲染器会根据这些关键信息执⾏“快捷路径”**，从⽽提升运⾏时的性能。

### patchFlag与block

- patchFlag
  patchFlag，它的值是⼀个数字。只要虚拟节点存在该属性，我们就认为它是⼀个动态节点。这⾥的 patchFlag 属性就是所谓的补丁标志。

- block 与dynamicChildren
  把带有patchFlag 属性的虚拟节点称为“块”，即 Block。所以，⼀个Block 本质上也是⼀个虚拟 DOM 节点，只不过它⽐普通的虚拟节点多出来⼀个⽤来存储动态⼦节点的dynamicChildren 属性。

### 更新动态内容与靶向更新

  渲染器的更新操作将会以 Block 为维度。也就是说，当渲染器在更新⼀个 Block 时，**会忽略虚拟节点的children 数组，⽽是直接找到该虚拟节点的dynamicChildren 数组**，并**只更新该数组中的动态节点**。这样，在更新时就实现了跳过静态内容，只更新动态内容。同时，**由于动态节点中存在对应的补丁标志，所以在更新动态节点的时候，也能够做到靶向更新**。

### Block 节点

  什么情况下需要将⼀个普通的虚拟节点变成 Block 节点呢？实际上，在编写模板代码的时候，所有模板的根节点都会是⼀个 Block 节点，此外，任何带有 v-for、v-if/v-else-if/v-else 等指令的节点都需要作为Block 节点。

  【注意】dynamicChildren 数组中收集的动态节点是忽略虚拟 DOM 树层级的，不仅有v-if 指令的节点会让虚拟 DOM 树的结构不稳定，带有 v-for 指令的节点也会让虚拟 DOM 树变得不稳定，因此需要把带有这些指令的节点也作为Block节点。
  **所谓结构不稳定，从结果上看，指的是更新前后⼀个 block的 dynamicChildren 数组中收集的动态节点的数量或顺序不⼀致**。

### 如何将根节点变成⼀个 Block？如何将动态⼦代节点收集到该 Block 的 dynamicChildren 数组中？

  这里有⼀个重要的事实，即在渲染函数内，对 **创建虚拟节点(createVNode) 函数的调⽤是层层的嵌套结构**，并且该函数的执⾏顺序是“**内层先执⾏，外层后执⾏**”。

### Fragment

  在v-for循环产生的虚拟节点中，使用了Fragment来表达 v-for 循环产⽣的虚拟节点，并让其充当 Block 的⾓⾊来解决 v-for 指令导致的虚拟 DOM 树结构不稳定问题。但**Fragment 本⾝收集的动态节点仍然⾯临结构不稳定的情况**，这种情况，没有更好的解决办法，**只能放弃根据dynamicChildren 数组中的动态节点进⾏靶向更新的思路，并回退到传统虚拟 DOM 的 Diff ⼿段**，即直接使⽤ Fragment 的children ⽽⾮ dynamicChildren 来进⾏ Diff 操作。

  但需要注意的是，Fragment 的⼦节点（children）仍然可以是由 Block 组成的数组。

  【注意】如果v-for 指令的表达式是常量，那么就会形成稳定的Fragment。

### 静态提升

 在虚拟 DOM 的描述中存在两个 p 标签，⼀个是纯静态的，⽽另⼀个拥有动态⽂本。当响应式数据 的值发⽣变化时，整个渲染函数会重新执⾏，并产⽣新的虚拟 DOM 树。这个过程有⼀个**明显的问题，即纯静态的虚拟节点在更新时也会被重新创建⼀次**。很显然，这是没有必要的，所以我们需要想办法避免由此带来的性能开销。⽽**解决⽅案就是所谓的“静态提升”，即把纯静态的节点提升到渲染函数之外**。

 当把纯静态的节点提升到渲染函数之外后，在**渲染函数内只会持有对静态节点的引⽤**。当响应式数据变化，并使得渲染函数重新执⾏时，并**不会重新创建静态的虚拟节点，从⽽避免了额外的性能开销**。

 【注意】静态提升是以树为单位的。

 p 标签存在动态绑定的⽂本内容，因此整个节点都不会被静态提升。但**该节点的所有 props 都是静态的，因此在最终⽣成渲染函数时，我们可以将纯静态的 props 提升到渲染函数之外**。

### 预字符串化

  预字符串化是基于静态提升的⼀种优化策略。静态提升的虚拟节点或虚拟节点树本⾝是静态的，预字符串化能够将这些静态节点序列化为字符串，并⽣成⼀个
Static 类型的 VNode。

  这么做有⼏个明显的优势。

- ⼤块的静态内容可以通过 innerHTML 进⾏设置，在性能上具有⼀定优势。
- 减少创建虚拟节点产⽣的性能开销。
- 减少内存占⽤。

### 缓存内联事件处理函数

  每次重新渲染时（即 render 函数重新执⾏时），都会为组件创建⼀个全新的 props 对象。同时，props 对象中
内联事件属性的值也会是全新的函数。这会导致渲染器对组件进⾏更新，造成额外的性能开销。为了避免这类⽆⽤的更新，我们
需要对内联事件处理函数进⾏缓存。这样，当渲染函数重新执⾏并创建新的虚拟 DOM 树时，会优先读取缓存(cache)中的事件处理函数。

### v-once

当编译器遇到v-once 指令时，会利⽤前面的 cache 数组来缓存渲染函数的全部或者部分执⾏结果。那么后续更新导致渲染函数重新执⾏时，会优先读取缓存的内容，⽽不会重新创建虚拟节点。同时，由于虚拟节点被缓存，意味着更新前后的虚拟节点不会发⽣变化，因此也就不需要这些被缓存的虚拟节点参与 Diff 操作。

使⽤ v-once 包裹的动态节点不会被⽗级 Block 收集。因此，被 v-once 包裹的动态节点在组件更新时，⾃然不会参与 Diff 操作。

v-once 指令能够从两个⽅⾯提升性能：

- 避免组件更新时重新创建虚拟 DOM 带来的性能开销。因为虚拟
DOM 被缓存了，所以更新时⽆须重新创建。
- 避免⽆⽤的 Diff 开销。这是因为被 v-once 标记的虚拟 DOM 树
不会被⽗级 Block 节点收集。

## 十八、同构渲染

  vue.js可以用于构建客户端应用程序，组件的代码在浏览器中运行，并输出DOM元素（**客户端渲染Client-Side-Rendering:csr**）；
  vue.js还可以在Node.js环境中运行，它可以将同样的组件渲染为字符串并发送给浏览器（**服务端渲染Server-Side-Rendering:ssr**）；

  两者结合在一起，则为**同构渲染Isomorphic-Rendering**。

### 服务端渲染SSR

  当站点**强调内容本身，不强调与用户之间具有高强度的交互**，一般采用的是服务端渲染技术实现。

#### 服务端渲染工作流程

(1) ⽤户通过浏览器请求站点。
(2) 服务器请求 API 获取数据。
(3) 接⼝返回数据给服务器。
(4) 服务器根据模板和获取的数据拼接出最终的 HTML 字符串。
(5) 服务器将 HTML 字符串发送给浏览器，浏览器解析 HTML 内
容并渲染。

传统的服务端渲染的用户体验非常差，任何一个微小的操作都可能导致页面刷新。

### 客户端渲染CSR

  SSR是在服务端完成模板与数据的融合；
  而CSR是在浏览器中完成模板与数据的融合，并渲染出最终的HTML代码。

#### CSR工作流程

(1) 客户端向服务器或CDN发送请求，获取**静态HTML页面**。
  此时获取的HTML页面通常为空页面，即“白屏”，但包含style,link,script等标签。

(2) 浏览器**解析HTML内容**，并加载HTML中引用的资源，如link,script标签引用的资源。
  接着，服务器或CDN将响应的资源返回给浏览器，**浏览器对CSS和JS代码进行解释和执行**。
  **页面渲染任务由js来完成**，当JS被解释和执行后，才渲染出页面内容，“白屏”结束。

(3) 客户端通过AJAX技术请求API获取数据，一旦接口返回数据，客户端就会完成**动态内容的渲染**，并呈现完整的页面。

当用户再次通过点击“跳转”到其他页面时，浏览器并不会真正的进行跳转动作， 既不会进行刷新，而是通过前端路由的方式动态地渲染页面，形成良好的交互体验。

### CSR 与 SSR的比较

  对于搜索引擎优化（SEO）而言：SSR对SEO更加友好；
  而CSR会出现白屏问题，SSR会占用消耗更多的服务端资源；
  CSR对于用户体验会更好。

### 集CSR、SSR优点于一身：同构渲染

#### 同构渲染的工作流程

(1)首次访问或刷新页面时，整个页面的内容是在服务端完成渲染，浏览器最终得到渲染好的**HTML纯静态页面**（包含link,script等标签），注意，这里的静态HTML页面会**包含当前页面所需要的初始化数据**，即在服务器同构API请求的数据会被序列化为字符串，并拼接到静态的HTML字符串中。

(2)浏览器解析并渲染HTML页面，从CDN或服务器获取响应的资源。

(3)资源加载完毕后，进行激活操作，即vue.js中常说的hydration。激活包含两部分工作内容：

- vue.js在当前页面已经渲染的DOM元素以及vue.js组件所渲染的虚拟DOM之间建立联系；
- vue.js从HTML页面中提取由服务端序列化后发送过来的数据，用以初始化整个vue.js应用程序。

激活完成后，整个应用程序已经被vue.js接管为CSR应用程序，后续操作都会按照CSR应用程序的流程来执行。如果刷新页面，仍然会进行服务端渲染，再进行激活，即重复以上流程。
