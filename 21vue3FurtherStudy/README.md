# VUE3

## 一、 框架设计的各项权衡

### 声明式 与 命令式框架

  命令式框架更注重**过程**，而声明式框架更注重**结果**，它会将具体实现过程封装起来。
  比如**vue.js就是声明式框架**，其内部的实现一定是命令式的，而暴露给用户的则是声明式的。

### 性能与维护性

  声明式的代码性能**不优于**命令式的代码。
  因为框架本身就是**封装了命令式的代码才实现面向用户的声明式**。
  但声明式代码的**维护性更强**， 因为命令式代码需要维护的是**整个实现的过程**， 而声明式代码内部封装好之后，后续需要维护的则是暴露给用户的一些方法等。

  命令式代码的更新性能消耗 = 直接修改的性能消耗；
  声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。

  【框架设计】：在提高可维护性的同时，实现最小的性能消耗。

  虚拟DOM则是为了最小化找出差异的性能消耗而出现的。

- 利用innerHTML创建页面的性能 = HTML字符串拼接的计算量+innerHTML的DOM计算量
  可能需要全量创建新的DOM元素进行更新

- 利用虚拟DOM创建页面的性能 = 创建js对象的计算量（对真实DOM的描述） + 创建真实DOM的计算量
  进行差量创建与更新

  【性能比较】
  innerHTML（模板）: 心智负担中等，性能差
  虚拟DOM：心智负担小，可维护性强，性能不错
  原生JS（利用createElement等方法）：心智负担大，可维护性差，性能强

### 运行时，编译时，编译运行时框架

- 纯运行时
  用户直接提供数据对象而无需编译

- 纯编译时
  将HTML字符串直接编译成可执行的js命令式代码

- 编译 + 运行时
  用户可以提供HTML字符串，我们将其编译成数据对象，再交给运行时处理。
  有编译步骤，可以分析用户提供的内容。

  【vue3是 运行时 + 编译时的架构】

## 二、 框架设计的核心要素

1. 提供友好的警告信息
2. 利用tree-shaking排除dead-code以实现框架的打包体积最小化
3. 满足不同需求场景下的框架的输出产物
4. 出于灵活性与兼容性的考虑，框架可提供多种能力或功能（如VUE3向下兼容VUE2）
5. 良好的框架错误处理

## 三、 vue3的设计思想

### 渲染器与编译器

渲染器与编译器是vue.js的核心组成部分。

- 虚拟DOM
  用js对象来描述真实的DOM结构
  例如：

  ```js
  const vnode = {
    tag: 'div',
    prop: {
      onClick: () => {}
    },
    children: {}
  }

  ```

- 渲染器
  把虚拟DOM对象渲染成真实DOM对象。

  - 渲染器实现步骤
  创建：
  1. 根据虚拟节点（vnode）对象创建DOM元素
  2. 为DOM元素添加属性和事件
  3. 处理children

  更新
  需要精确的找到虚拟节点（vnode）对象的变更点并只更新变更的内容。

- 组件的本质
  组件其实就是一组虚拟DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象，但这个对象里面必须要有一个函数用来产出组件所需要渲染的虚拟DOM。

- 编译器
  编译器作用为将模板编译为渲染函数。
  例如vue文件中

  ```vue
  <template>
    <div @click="handler">
      click me
    </div>
  </template>
  <script>
  export default{
    data(){},
    methods: {
      handler() {}
    }
  }
  </script>
  ```

  编译器会把template里边的模块内容编译成渲染函数并添加到script标签里的组件对象上，最终在浏览器上运行的代码即为:

  ```js
  export default{
    data(){},
    methods: {
      handler() {}
    },
    render() {
      return h('div', { onClick: handler }, 'click me')
    },
  }
  ```

- vue中的渲染器与编译器
  编译器将模板中的内容编译成渲染函数，然后渲染器将渲染函数中返回的虚拟DOM渲染为真实DOM，当发生更新时，渲染器自行寻找变更点，并只更新变化的内容。

## 四、 vue3的响应式--响应系统的概念与实现

### 副作用函数effect

所谓的副作用函数，就是该函数的执行会直接或间接影响到其他函数的执行，因而产生了一定的副作用影响。
例如一个函数修改了全局变量，产生了副作用影响。

在 Vue 3 中，副作用函数（Effect Function）通常指的是那些依赖于响应式数据并在数据变化时重新执行的函数。

### 响应式数据

在一个副作用函数中读取了某个对象的属性，当对象的属性发生变化的时候，该副作用函数会重新执行，则该对象为响应式数据。

### 响应式系统的实现原理

  拦截一个对象的读取与设置操作，当读取对象字段的时候，将副作用函数存储至一个“桶”中，然后返回属性值；当设置对象字段的时候，先更新对象字段数据，然后将副作用函数从桶中取出并执行。

  其中有三个角色：

  1. 被操作的代理对象target
  2. 被操作的字段名key
  3. 使用effect函数注册的副作用函数effectFn

  三个角色有着树形结构的关系
  target -> key -> effectFn

  为使得副作用函数与被操作的目标字段建立起明确的关系，具体实现为使用WeakMap代替Map来作为存储副作用函数的“桶”的数据结构。

  其中WeakMap的键是原始对象target, WeakMap的值是一个Map实例，Map的键是原始对象的字段名key，Map的值是副作用函数组成的Set集合（即key的依赖集合）。

- 【注意】为何使用WeakMap作为存储副作用函数的数据结构
  WeakMap对key是弱引用，不影响垃圾回收器的工作。一旦key被垃圾回收器回收，那对应的键和值就访问不到了。
  所以WeakMap经常用于存储那些只有当key所引用的对象存在时（没有被回收）才有价值的信息。

### computed与watch

  在vue3中，computed与watch的实现本质上都是利用的副作用函数effect。

## 五、 非原始值的相应方案

### proxy 与reflect

- Proxy
  Proxy可以创建一个**代理对象**，它能够实现对**其他对象**的代理。

  **代理**指的是对一个对象的**基本语义**的代理，它允许我们**拦截并重新定义**对一个对象的基本操作。
  
  类似**读取，设置对象属性值**等操作属于基本语义的操作。

  函数也属于对象，**调用函数也是对一个对象的基本操作**。

  在proxy中是用get方法拦截对象的读取操作，是用set方法拦截对象的设置操作，是用apply方法拦截函数的调用操作。

  【注意】proxy只能够拦截对一个对象的基本操作。

- Reflect
  Reflect为内置的js对象，它是不可构造的；
  Reflect中所有的属性与方法都是静态的；
  Reflect内部封装了一系列对对象的底层操作；
  Reflect成员方法就是Proxy处理对象的默认实现；
  任何在Proxy拦截器中能找到的方法，都能在Reflect中找到同名方法。

  - Reflect作用
  
  ```js
  // 设置1
  let obj = { name: "yq" };
  obj.name = "yqcoder";
  console.log(obj); // { name: 'yqcoder' }

  // 设置2
  let obj = { name: "yq" };
  Reflect.set(obj, "name", "yqcoder");
  console.log(obj); // { name: 'yqcoder' }
  ```

  以上两种属性设置方法的效果是一样的，区别在于，通过语法或者一些 API 去调用对象的内部方法的话，它会经过一些规则和步骤，在这些规则和步骤当中，有一步是在调用这个内部方法。如果不希望有这些额外步骤存在，那就需要直接去调用对象的基本方法了，这时就可以使用Reflect。

  而且，对于Reflect.get方法可以传入第三个参数从而更改对象的this指向。

- 关于对象Object的代理

  代理对象的本质是，通过查阅规范并找到可拦截的基本操作的方法。而对于复合操作，则是查阅规范看其依赖的基本操作是那些，然后对基本操作进行拦截处理从而间接地处理复合操作。

  1. 访问对象属性 obj.foo
  通过get拦截函数实现。

  2. 判断对象或原型上是否存在给定的key: key in obj
  通过规范可知，可通过has拦截函数实现对in操作符的代理。

  3. for...in 循环遍历对象
  使用ownKeys拦截函数拦截Reflect.ownKeys操作，从而间接拦截for...in循环

  注意区分遍历对象的目的是修改对象属性值还是只是读取属性值。
  4. 删除属性操作 delete p.foo
  使用deleteProperty拦截删除操作，并调用Reflect.deleteProperty来完成属性的删除工作。

- 关于数组的代理
  数组对象除了 [[DefineOwnProperty]] 这个内部方法
  之外，其他内部方法的逻辑都与常规对象相同。

  【重点】在于数组读取|设置时会直接或间接读取length属性，所以在读取或设置时需做出拦截响应length相关操作
  此外，需要重写数组的一些方法（数组查找方法、隐式修改数组长度的一些数组原型方法）以解决数据改动无法响应以及一些不必要的响应的问题
  在不同的副作⽤函数内对同⼀个数组执⾏数组push,pop等间接改变数组长度的⽅法，会导致多个副作⽤函数之间循环调⽤，最终导致
  调⽤栈溢出，解决方法为标记一个全局变量shouldTrack，当这些⽅法间接读取 length 属性值时，我们会先将
  shouldTrack 的值设置为 false，即禁⽌追踪。这样就可以断开
  length 属性与副作⽤函数之间的响应联系，从⽽避免循环调⽤导致
  的调⽤栈溢出。

- 关于Set和Map等集合类型数据的代理

  1. Set属性与方法
  size, add, clear, delete, has, keys, values, entries, foreach

  2. Map属性与方法
  size, set, get, clear, delete, has, keys, values, entries, foreach

Set和Map数据类型的操作方法相似，不同的是，Set通过add(value)添加元素，
Map通过set(key, value)添加键值对，而且Map可以通过get(key)获取对应key的值。

  【重点】对于集合类型数据，对其特定的属性以及一些方法进行自定义拦截|重写，从而实现响应式数据

## 六、原始值的响应式方案

  由于proxy的代理目标对象必须是非原始值，故要拦截对原始值的操作，解决方法是：使用一个非原始值去“包裹”原始值。

## 七、渲染器

### 概念

- 渲染器（renderer）
  【注意】区分renderer与render（渲染）
  渲染器是更加宽泛的概念，它包含渲染。
  作用：将虚拟DOM（vdom）渲染为特定平台上的真实元素，
  渲染器不仅可以用来渲染，还可以用来激活已有的DOM元素（同构渲染时）

  渲染器将虚拟DOM渲染为真实DOM的过程称为挂载（mount）。

  渲染器接受一个挂载点作为参数，挂载点 — — 即一个dom元素，也就是容器（container）元素，
  渲染器把内容渲染到容器中。

  【打补丁】
  渲染器会使用newVnode与上一次的oldVnode进行对比，试图找到并更新变更点，这个过程叫做打补丁。

- 响应系统和渲染器的关系
  利用响应系统的能力，自动调用渲染器完成页面的更新与渲染。

## 八、挂载与更新

### HTML attributes 与 DOM properties

**HTML attributes**即定义在HTML标签上的属性

在浏览器解析完html代码之后，会创建与之相符的**DOM元素对象**。

**DOM properties**即DOM元素对象下的属性。

DOM元素对象上与与HTML 标签上同名的属性，但不总是一模一样的。

HTML Attributes 与 DOM Properties 具有相同
名称（即 id）的属性看作直接映射。

HTML标签属性的作用是设置与之对应的DOM元素属性的初始值。

但一个html标签属性可能和与之对应的DOM元素上的多个属性相关联。
比如value="test"与el.value、el.defaultValue相关联。

### 卸载

根据vnode对象获取与其相关联的真实DOM对象，然后使用原生DOM操作方法移除该DOM元素
注意：将真实DOM元素绑定在vnode对象上，即vnode.el = el，使得vnode与真实DOM建立了联系，从而在卸载阶段vnode可以获取到真实DOM。

### 事件的处理

如何将虚拟节点上描述的事件添加到真实DOM上： 使用addEventListener来进行事件绑定与监听。

事件更新方式：
    一般思路方案：移除之前添加绑定的事件处理函数，再将新的事件处理函数绑定到DOM元素上。
    性能优化方案：在绑定事件时，绑定一个伪造的事件处理函数invoker，并把真正的事件处理函数设置为invoker.value;
                  在更新事件时，不再调用removeEventListener来移除绑定事件，只需更新invoker.value的值即可。
                  【注】使用伪造的事件处理函数不仅提高了性能，还解决了事件更新与事件冒泡之间的影响问题。

### 事件冒泡与更新时机

如何处理事件与更新时机的问题：解决⽅案是，利
⽤事件处理函数被绑定到 DOM 元素的时间与事件触发时间之间的差
异。我们需要屏蔽所有绑定时间晚于事件触发时间的事件处理函数的
执⾏。

## 九、简单diff算法

当新旧vnode的子节点均为一组节点时，为了**减小更新节点的性能开销**，通常使用diff算法来比较操作两组节点。

### DOM的复用与key的作用

vnode的key就像虚拟节点的身份证，只要vnode的type数组和key属性相同，就认为两个虚拟节点是相同的，即可以进行DOM复用。

**所谓的复用并不代表不用更新**，通过遍历新vnode，通过新vnode的key获取到旧vnode中具有相同key的节点，然后对新旧两节点进行差量更新。

### 找到需移动的元素并移动

- 寻找方式：
  遍历新vnode子节点，将子节点在旧vnode子节点中的索引定义为：在旧 children 中寻找具有相同 key 值节点的过程中，遇到的**最⼤索引值**。如果在后续寻找的过程中，**存在索引值⽐当前遇到的最⼤索引值还要⼩的节点**，则意味着该节点**需要移动**。 ⽤ lastIndex 变量存储整个寻找过程中遇到的最⼤索引值。

- 移动方式：
  注意，**新vnode子节点的顺序其实就是更新后真实 DOM 节点应有的顺序**。
  需要获取当前 newVNode 节点的前⼀个虚拟节点，然后使⽤ insert 函数完成节点的移动，其中 insert 函数依赖浏览器原⽣的 insertBefore 函数。

### 添加新元素与移除不存在的元素

- 添加新元素
  为了将新节点挂载到正确位置，需要先获取锚点元素：找到当前新newVNode 的前⼀个虚拟节点，即**prevVNode，如果存在，则使⽤它对应的真实 DOM 的下⼀个兄弟节点作为锚点元素；如果不存在，则说明即将挂载的 newVNode 节点是容器元素的第⼀个⼦节点，此时应该使⽤容器元素的 container.firstChild 作为锚点元素**。最后，将锚点元素 anchor 作为 挂载patch 函数的第四个参数，调⽤ patch 函数完成节点的挂载。

- 删除节点
遍历旧的⼀组⼦节点，然后去新的⼀组⼦节点中寻找具有相同 key 值的节点。如果找不到，则说明应该删除该节点。

## 十、双端DIFF算法

【注意】简单diff算法对于DOM元素的移动操作并不是最优解。

### 双端diff算法

双端diff算法是同时对新旧两组子节点的两个端点进行比较的算法。

#### 双端比较方式

  1. **定义索引变量等**
    新旧两组子节点oldChildren、newChildren
    先分别定义四个端点索引：
    let oldStartIdx = 0
    let oldEndIdx = oldChildren.length - 1
    let newStartIdx = 0
    let newEndIdx = newChildren.length - 1

  2. **循环比较处理**
    当新|旧节点组起始端点索引均小于等于终止端点索引，进行以下循环
      1. 旧新子节点组的第一个节点进行比较，若节点可复用，对新旧节点进行打补丁，但无需进行DOM移动操作，同时更新对应的端点索引；
      2. 旧新子节点组的最后一个节点进行比较，若节点可复用，对新旧节点进行打补丁，但无需进行DOM移动操作，同时更新对应的端点索引；
      3. 旧子节点组的第一个节点与新子节点组的最后一个节点进行比较，若节点可复用，进行节点差量更新，且进行DOM移动操作完成更新，同时更新对应的端点索引；
      4. 旧子节点组的最后一个节点但与新子节点组的第一个节点进行比较，若节点可复用，则进行节点差量更新，且进行DOM移动操作完成更新，同时更新对应的端点索引；

### 双端diff算法的优势

对于同样的例⼦，使⽤双端 Diff 算法相比于采⽤简单 Diff 算法，能够有效减少DOM 移动操作次数来完成更
新，从而提供了性能。

## 十一、快速diff算法

### 快速diff方式

  思路：先获取新旧两组节点中相同的前置节点与后置节点，由于它们在新旧两组⼦节点中
的相对位置不变，所以我们⽆须移动它们，但仍然需要在它们之间打补丁。

- 更新前置节点
  建立索引j，指向新旧两组节点的开头；开启while循环，向后遍历这两组⼦节点，
  直到遇到 key 值不同的节点为⽌。

- 更新后置节点
  建立两个索引 newEnd 和 oldEnd，分别指向新旧两组⼦节点中的最后⼀个节点；开启while循环，从后向前遍历两组子节点，
  直到遇到 key 值不同的节点为⽌。

- 处理新增节点与删除节点
  根据条件判断
  j > oldEnd && j <= newEnd  符合该条件说明新子节点组中存在遗留节点（j~newEnd范围的节点），且这些节点都是新增节点，因此需要挂载这些节点
  j > newEnd && j <= oldEnd  符合该条件说明旧子节点组中存在遗留节点（j~oldEnd范围的节点），因此需要卸载这些节点

- 部分未经处理节点
  构造数组source，⻓度等于新的⼀组⼦节点在经过预处理之后剩余未处理节点的数量，并且 source 中每个元素的初始值都是 -1。

  source数组用处：
  source 数组将⽤来存储新的⼀组⼦节点中的节点在旧的⼀组⼦节点中的位置索引（默认-1，即不存在于旧子节点中），后⾯将会使⽤它计算出⼀个**最⻓递增⼦序列**，并⽤于辅助完成 DOM 移动的操作，

### 总结

  快速 Diff 算法在实测中性能最优。它借鉴了⽂本 Diff 中的预处理思路，**先处理新旧两组⼦节点中相同的前置节点和相同的后置节点**。
  当前置节点和后置节点全部处理完毕后，如果⽆法简单地通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引
  关系，**构造出⼀个最⻓递增⼦序列**。**最⻓递增⼦序列所指向的节点即为不需要移动的节点**。

## 十二、组件化

### 组件

  将一个大的页面拆分为多个部分，每一个部分都可以作为单独的组件，这些组件共同组成完整的页面。
  从用户角度而言：一个有状态组件就是一个**选项对象**；
  从渲染器的内部实现来看：一个组件则是一个特殊类型的虚拟节点（vnode）；

  在描述组件的虚拟节点中，使用vnode.type来存储组件的选项对象。

  ```js
  const MyComponent = {
    name: 'MyComponent',
    // data函数定义组件自身的状态
    data: function() {
      return {
        text: 'test text'
      }
    },
    // 组件的渲染函数，其返回值必须为虚拟DOM对象
    render() {
      return {
        type: 'div',
        children: '我是文本内容'
      }
    }
  }
  ```

### 渲染组件

  **一个组件必须包含一个渲染函数**，即render函数，且该渲染函数**返回的应该是一个虚拟节点**。

### 组件状态

  组件中用data函数来定义组件自身的状态

  组件自更新原理： **使用reactive把data函数返回的状态数据变为响应式，同时使用effect函数将组件的渲染操作包装起来，从而实现组件的自更新**。

  更新优化： ⽆论对响应式数据进⾏多少次修改，副作⽤函数都只会重新执⾏⼀次。为此，需要实现⼀个**调度器**，当副作⽤函数需要重新执⾏时，不会⽴即执⾏它，⽽是将它**缓冲到⼀个微任务队列中**，等到执⾏栈清空后，再将它从微任务队列中取出并执⾏。有了缓存机制， 就有机会**对任务进⾏去重**，从⽽避免多次执⾏副作⽤函数带来的性能开销。

### 组件实例

  一个组件实例本质上就是一个对象，它包含组件有关的状态信息，例如组件的⽣命周期函数、组件渲
染的⼦树（subTree）、组件是否已经被挂载、组件⾃⾝的状态（data），等等。

### 组件的生命周期原理

从组件的选项对象中取得注册到组件上的⽣命周期函数，然后在合适的时机调⽤它们，这其实就是组件⽣命周期的实现原理。

### props

 ```js
  const MyComponent = {
    name: 'MyComponent',
    // data函数定义组件自身的状态
    data: function() {
      return {
        text: 'test text'
      }
    },
    props: { // 接受props
      title: String,
    },
    // 组件的渲染函数，其返回值必须为虚拟DOM对象
    render() {
      return {
        type: 'div',
        children: `我是文本内容${this.title}`, // 访问props数据
      }
    }
  }

  const vnode = {
    type: MyComponent,
    props: {
      title: 'a big title',
    }
  }
  ```

  【注意】我们需要关注的是：
    为组件传递的 props 数据，即vnode.props
    在组件选项对象内定义的props对象，即MyComponent.props
    把父组件自更新引起的子组件的更新叫做**子组件的被动更新**。

### setup

  setup 函数主要⽤于配合组合式 API，为⽤户提供⼀个地⽅，**⽤于建⽴组合逻辑、创建响应式数据、创建通⽤函数、注册⽣命周期钩⼦等**能⼒。在组件的整个⽣命周期中，**setup 函数只会在被挂载时执⾏⼀次**，它的返回值可以有两种情况。
  (1) 返回⼀个函数，该函数将作为组件的 render 函数；
  (2) 返回⼀个对象，该对象中包含的数据将暴露给模板使⽤。

### 组件事件与emit

  emit ⽤来发射（触发）组件的⾃定义事件。
  发射⾃定义事件的本质就是根据事件名称去props 数据对象中寻找对应的事件处理函数并执⾏。

### 插槽slot
  
  组件的插槽指组件会预留⼀个槽位，该槽位具体要渲染的内容由⽤户插⼊。
  组件模板中的插槽内容会被编译为插槽函数，⽽插槽函数的返回值就是具体的插槽内容。

  渲染插槽内容的过程，就是调⽤插槽函数并渲染由其返回的内容的过程。

### 注册生命周期钩子函数

   Vue.js 3 中，有⼀部分组合式 API 是⽤来注册⽣命周期钩⼦函数的，例如 onMounted、onUpdated 等。
   注意这些注册方法只能在setup函数中调用

## 十三、异步组件与函数式组件

- 异步组件
  **以异步的方式加载并渲染一个组件**，在代码分割与服务端下发组件等场景中尤为重要。

  ```vue
  <template>
    <AsyncComp />
  </template>
  <script>
    export default {
      components: {
        // 使⽤ defineAsyncComponent 定义⼀个异步组件，它接收⼀个加载器作为参数
          AsyncComp: defineAsyncComponent(() => import('CompA'))
        }
      }
  </script>
  ```

  【异步组件】
  - 允许⽤户指定加载出错时要渲染的组件。
  - 允许⽤户指定 Loading 组件，以及展⽰该组件的延迟时间。
  - 允许⽤户设置加载组件的超时时⻓。
  - 组件加载失败时，为⽤户提供重试的能⼒。

- 函数式组件
  使用一个**普通函数定义组件**，并**使用该函数的返回值作为组件要渲染的内容**。
  函数式组件的特点：无状态，编写简单且直观。
  
  【注意】在 Vue.js3 中使⽤函数式组件，主要是因为它的简单性，⽽不是因为它的性能
  好。”这是因为在 Vue.js 3 中，即使是有状态组件，其初始化性能消耗也⾮常⼩。

  在⽤户接⼝层⾯，⼀个函数式组件就是⼀个返回虚拟 DOM 的函数。
  函数式组件没有⾃⾝状态，但它仍然可以接收由外部传⼊的props。

## 十四、vue的内建组件与模块

  Vue.js 中有⼏个⾮常重要的内建组件和模块：如KeepAlive 组件、Teleport 组件、Transition 组
件等。

### KeepAlive组件

- http协议中的KeepAlive
  一个http连接会在每次请求/响应结束后关闭，在下一次请求发生时重新建立一个http连接，频繁地销毁、创建连接会带来额外的性能开销。
  而keepAlive为http持久连接，它允许多个请求或响应公用一个tcp连接。

- vue的内建KeepAlive组件
  避免一个组件频繁的销毁与创建。

- KeepAlive的实现原理
  本质上是缓存管理，再加上特殊的挂载与卸载逻辑。

  将被 KeepAlive 的组件从原容器搬运到另外⼀个隐藏的容器中，实现“假卸载”。当被搬运到隐藏容器中的组件需要再次被“挂载”时，不能执⾏真正的挂载逻辑，⽽应该把该组件从隐藏容器中再搬运到原容器。这个过程对应到组件的⽣命周期，其实就是 activated 和 deactivated。

  **KeepAlive 组件与渲染器的结合⾮常深**。

### Teleport （vue3新增）

  通常情况下，将虚拟DOM渲染为真实DOM，真实DOM的层级结构与真实DOM的层级结构是保持一致的。
  但有时候需要将组件渲染到指定容器中，**Teleport组件则是可以将指定内容渲染到特定容器中，⽽不受 DOM 层级的限制**。

  与 KeepAlive 组件⼀样，Teleport 组件也**需要渲染器的底层⽀持**。

  【注意】要将 Teleport 组件的渲染逻辑从渲染器中分离出来，这样的好处是：避免代码膨胀，并且在打包时有利于进行tree shaking。

### Transition组件

  **Transition组件与渲染器的结合更加密切**。

  过渡效果本质上**是⼀个DOM元素在两种状态间的切换**，浏览器会根据过渡效果⾃⾏完成 DOM 元素的过渡。这⾥的过渡效果指的是持续时⻓、运动曲线、要过渡的属性等。

#### Transition组件的原理

- 当 DOM 元素被挂载时，将动效附加到该 DOM 元素上；
- 当 DOM 元素被卸载时，不要⽴即卸载 DOM 元素，⽽是等到附加到该 DOM 元素上的动效执⾏完成后再卸载它。

【注意】
transition组件本身不会渲染任何额外的内容，它只是通过默认的插槽读取过渡元素，并渲染需要过渡的元素；
transition组件的作用：即在过渡元素的虚拟节点上田间transition相关的钩子函数。

## 十五、编译器

### 编译器

**编译器**其实只是一段程序，它用来将“一种语言A”（源代码）翻译成“另外一种语言B”（目标代码）。

编译器将源代码翻译成目标代码的过程叫做**编译**。

**完整的编译过程包括**：词法分析、语法分析、语义分析，中间代码生成、优化、目标代码生成。

### vue.js模板编译器

vue.js的模板编译器的目标代码为渲染函数。

具体为：vue.js编译器对vue模板进行词法与语法分析，得到模板AST，然后将模板AST转化为 js AST，接着根据js AST生成js代码，即渲染函数。

AST: abstract syntax tree，抽象语法树，用来描述模板。

语义分析:

- 检查 v-else 指令是否存在相符的 v-if 指令。
- 分析属性值是否是静态的，是否是常量等。
- 插槽是否会引⽤上层作⽤域的变量。
- ...等等。

【AST】AST具有与模板同构的嵌套结构

- 不同类型的节点是通过节点的 type 属性进⾏区分的。例如标签节点的 type 值为 'Element'。
- 标签节点的⼦节点存储在其 children 数组中。
- 标签节点的属性节点和指令节点会存储在 props 数组中。
- 不同类型的节点会使⽤不同的对象属性进⾏描述。例如指令节点拥有 name 属性，⽤来表达指令的名称，⽽表达式节点拥有content 属性，⽤来描述表达式的内容。

Vue.js 模板编译器的基本结构和⼯作流
程，它主要由三个部分组成：

- ⽤来将模板字符串解析为模板 AST 的解析器（parser）；
- ⽤来将模板 AST 转换为 JavaScript AST 的转换器（transformer）；
- ⽤来根据 JavaScript AST ⽣成渲染函数代码的⽣成器（generator）。
