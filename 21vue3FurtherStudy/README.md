# VUE3

## 声明式 与 命令式框架

    命令式框架更注重过程，而声明式框架更注重结果，比如vue.js就是声明式框架，其内部的实现一定是命令式的，而暴露给用户的则是声明式的。

### 性能与维护性

  声明式的代码性能不优于命令式的代码。
  因为框架本身就是封装了命令式的代码才是想面向用户的声明式。
  但声明式代码的维护性更强。

  声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。

  虚拟DOM则是为了最小化找出差异的性能消耗而出现的。

## 运行时，编译时，编译运行时框架

- 纯运行时
  用户直接提供数据对象而无需编译

- 纯编译时
  将HTML字符串直接编译成可执行的js命令式代码

- 编译 + 运行时
  用户可以提供HTML字符串，我们将其编译成数据对象，再交给运行时处理。
  有编译步骤，可以分析用户提供的内容。

  【vue3是 运行时 + 编译时的架构】

## 渲染器与编译器

渲染器与编译器是vue.js的核心组成部分。

- 渲染器
  把虚拟DOM对象渲染成真实DOM对象。

- 组件的本质
  组件其实就是一组虚拟DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象，但这个对象里面必须要有一个函数用来产出组件所需要渲染的虚拟DOM。

## vue3的响应式

### 副作用函数

所谓的副作用函数，就是该函数的执行会直接或间接影响到其他函数的执行，因而产生了一定的副作用影响。
例如一个函数修改了全局变量，产生了副作用影响。

### 响应式数据

在一个副作用函数中读取了某个对象的属性，当对象的属性发生变化的时候，该副作用函数会重新执行，则该对象为响应式数据。

### 响应式数据的实现原理

  拦截一个对象的读取与设置操作，当读取对象字段的时候，将副作用函数存储至一个“桶”中，当设置对象字段的时候，将副作用函数从桶中取出并执行。

### proxy 与reflect

- Proxy
  Proxy可以创建一个**代理对象**，它能够实现对**其他对象**的代理。

  **代理**指的是对一个对象的**基本语义**的代理，它允许我们**拦截并重新定义**对一个对象的基本操作。
  
  类似**读取，设置对象属性值**等操作属于基本语义的操作。

  函数也属于对象，**调用函数也是对一个对象的基本操作**。

  在proxy中是用get方法拦截对象的读取操作，是用set方法拦截对象的设置操作，是用apply方法拦截函数的调用操作。

- Reflect
  Reflect为内置的js对象，它是不可构造的；
  Reflect中所有的属性与方法都是静态的；
  Reflect内部封装了一系列对对象的底层操作；
  Reflect成员方法就是Proxy处理对象的默认实现；
  任何在Proxy拦截器中能找到的方法，都能在Reflect中找到同名方法。

  - Reflect作用
  
  ```js
  // 设置1
  let obj = { name: "yq" };
  obj.name = "yqcoder";
  console.log(obj); // { name: 'yqcoder' }

  // 设置2
  let obj = { name: "yq" };
  Reflect.set(obj, "name", "yqcoder");
  console.log(obj); // { name: 'yqcoder' }
  ```

  以上两种属性设置方法的效果是一样的，区别在于，通过语法或者一些 API 去调用对象的内部方法的话，它会经过一些规则和步骤，在这些规则和步骤当中，有一步是在调用这个内部方法。如果不希望有这些额外步骤存在，那就需要直接去调用对象的基本方法了，这时就可以使用Reflect。

  而且，对于Reflect.get方法可以传入第三个参数从而更改对象的this指向。

- 关于对象Object的代理

  代理对象的本质是，通过查阅规范并找到可拦截的基本操作的方法。而对于复合操作，则是查阅规范看其依赖的基本操作是那些，然后对基本操作进行拦截处理从而间接地处理复合操作。
