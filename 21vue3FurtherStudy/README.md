# VUE3

## 一 框架设计的各项权衡

### 声明式 与 命令式框架

  命令式框架更注重**过程**，而声明式框架更注重**结果**，它会将具体实现过程封装起来。
  比如**vue.js就是声明式框架**，其内部的实现一定是命令式的，而暴露给用户的则是声明式的。

### 性能与维护性

  声明式的代码性能**不优于**命令式的代码。
  因为框架本身就是**封装了命令式的代码才实现面向用户的声明式**。
  但声明式代码的**维护性更强**， 因为命令式代码需要维护的是**整个实现的过程**， 而声明式代码内部封装好之后，后续需要维护的则是暴露给用户的一些方法等。

  命令式代码的更新性能消耗 = 直接修改的性能消耗；
  声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。

  【框架设计】：在提高可维护性的同时，实现最小的性能消耗。

  虚拟DOM则是为了最小化找出差异的性能消耗而出现的。

- 利用innerHTML创建页面的性能 = HTML字符串拼接的计算量+innerHTML的DOM计算量
  可能需要全量创建新的DOM元素进行更新

- 利用虚拟DOM创建页面的性能 = 创建js对象的计算量（对真实DOM的描述） + 创建真实DOM的计算量
  进行差量创建与更新

  【性能比较】
  innerHTML（模板）: 心智负担中等，性能差
  虚拟DOM：心智负担小，可维护性强，性能不错
  原生JS（利用createElement等方法）：心智负担大，可维护性差，性能强

### 运行时，编译时，编译运行时框架

- 纯运行时
  用户直接提供数据对象而无需编译

- 纯编译时
  将HTML字符串直接编译成可执行的js命令式代码

- 编译 + 运行时
  用户可以提供HTML字符串，我们将其编译成数据对象，再交给运行时处理。
  有编译步骤，可以分析用户提供的内容。

  【vue3是 运行时 + 编译时的架构】

## 二 框架设计的核心要素

1. 提供友好的警告信息
2. 利用tree-shaking排除dead-code以实现框架的打包体积最小化
3. 满足不同需求场景下的框架的输出产物
4. 出于灵活性与兼容性的考虑，框架可提供多种能力或功能（如VUE3向下兼容VUE2）
5. 良好的框架错误处理

## 三 vue3的设计思想

### 渲染器与编译器

渲染器与编译器是vue.js的核心组成部分。

- 虚拟DOM
  用js对象来描述真实的DOM结构
  例如：

  ```js
  const vnode = {
    tag: 'div',
    prop: {
      onClick: () => {}
    },
    children: {}
  }

  ```

- 渲染器
  把虚拟DOM对象渲染成真实DOM对象。

  - 渲染器实现步骤
  创建：
  1. 根据虚拟节点（vnode）对象创建DOM元素
  2. 为DOM元素添加属性和事件
  3. 处理children

  更新
  需要精确的找到虚拟节点（vnode）对象的变更点并只更新变更的内容。

- 组件的本质
  组件其实就是一组虚拟DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象，但这个对象里面必须要有一个函数用来产出组件所需要渲染的虚拟DOM。

- 编译器
  编译器作用为将模板编译为渲染函数。
  例如vue文件中

  ```vue
  <template>
    <div @click="handler">
      click me
    </div>
  </template>
  <script>
  export default{
    data(){},
    methods: {
      handler() {}
    }
  }
  </script>
  ```

  编译器会把template里边的模块内容编译成渲染函数并添加到script标签里的组件对象上，最终在浏览器上运行的代码即为:

  ```js
  export default{
    data(){},
    methods: {
      handler() {}
    },
    render() {
      return h('div', { onClick: handler }, 'click me')
    },
  }
  ```

- vue中的渲染器与编译器
  编译器将模板中的内容编译成渲染函数，然后渲染器将渲染函数中返回的虚拟DOM渲染为真实DOM，当发生更新时，渲染器自行寻找变更点，并只更新变化的内容。

## 四 vue3的响应式

### 副作用函数

所谓的副作用函数，就是该函数的执行会直接或间接影响到其他函数的执行，因而产生了一定的副作用影响。
例如一个函数修改了全局变量，产生了副作用影响。

### 响应式数据

在一个副作用函数中读取了某个对象的属性，当对象的属性发生变化的时候，该副作用函数会重新执行，则该对象为响应式数据。

### 响应式数据的实现原理

  拦截一个对象的读取与设置操作，当读取对象字段的时候，将副作用函数存储至一个“桶”中，当设置对象字段的时候，将副作用函数从桶中取出并执行。

### proxy 与reflect

- Proxy
  Proxy可以创建一个**代理对象**，它能够实现对**其他对象**的代理。

  **代理**指的是对一个对象的**基本语义**的代理，它允许我们**拦截并重新定义**对一个对象的基本操作。
  
  类似**读取，设置对象属性值**等操作属于基本语义的操作。

  函数也属于对象，**调用函数也是对一个对象的基本操作**。

  在proxy中是用get方法拦截对象的读取操作，是用set方法拦截对象的设置操作，是用apply方法拦截函数的调用操作。

- Reflect
  Reflect为内置的js对象，它是不可构造的；
  Reflect中所有的属性与方法都是静态的；
  Reflect内部封装了一系列对对象的底层操作；
  Reflect成员方法就是Proxy处理对象的默认实现；
  任何在Proxy拦截器中能找到的方法，都能在Reflect中找到同名方法。

  - Reflect作用
  
  ```js
  // 设置1
  let obj = { name: "yq" };
  obj.name = "yqcoder";
  console.log(obj); // { name: 'yqcoder' }

  // 设置2
  let obj = { name: "yq" };
  Reflect.set(obj, "name", "yqcoder");
  console.log(obj); // { name: 'yqcoder' }
  ```

  以上两种属性设置方法的效果是一样的，区别在于，通过语法或者一些 API 去调用对象的内部方法的话，它会经过一些规则和步骤，在这些规则和步骤当中，有一步是在调用这个内部方法。如果不希望有这些额外步骤存在，那就需要直接去调用对象的基本方法了，这时就可以使用Reflect。

  而且，对于Reflect.get方法可以传入第三个参数从而更改对象的this指向。

- 关于对象Object的代理

  代理对象的本质是，通过查阅规范并找到可拦截的基本操作的方法。而对于复合操作，则是查阅规范看其依赖的基本操作是那些，然后对基本操作进行拦截处理从而间接地处理复合操作。
