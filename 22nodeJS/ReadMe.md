# Node.js further study

## Node

### NODEJS的由来

  什么是Node?——n**ode是一个javascript（严格来说是ecmascript）运行时（runtime）**，runtime即运行时组件，可理解为一种**编程语言的运行环境**，这个运行环境包括运行代码所需要的编译器（解释器）以及操作系统的底层支持等。

  node底层使用C++实现，语法则是遵循ecmascript规范。

  实际上, javascript一早就能运行在前后端,但后续javascript在web应用中盛行,javascript能在服务端中运行的这件事也渐渐被淡忘.

  node的出现,将服务器端javascript这个领域重新焕新.

### 选用JS实现node

  设计高性能web服务器的几个要点：**事件驱动、非阻塞I/O**。

  考虑到**高性能、符合事件驱动、没有历史包袱**这三个主要原因，JavaScript成为了Node的实现语言。

  node的实现者起初将其项目称为web.js，目标为web服务器，后续项目发展变成了**构建网络应用的框架**。node发展为一个**强制不共享任何资源的单线程、单进程系统**，包含适宜网络的库，为构建大型分布式应用程序提供基础设施，目标是成为一个**构建快速、可伸缩的网络应用平台**。
  通过**通信协议**来组织许多node，从而通过**扩展**来达成构建大型网络应用的目的，每个**Node进程都构成这个网络应用的节点**。

### 浏览器与node

  node 与 chrome浏览器相比，除了HTML、Webkit和显卡这些ui技术没有支持外，Node结构与chrome十分相似（javascript，v8等）。

  **浏览器和Node都是基于事件驱动的异步架构**，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O。

  在node中，js可以访问本地文件，搭建微博socket服务器，可以连接数据库，可以向web workers一样玩转多进程。

  node不处理UI，但用 与浏览器相同的机制和原理运行。

  node打破了js只能在浏览器中运行的局面，**前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价**。

### Node的特点

  1. 异步I/O
  Node底层构建了众多异步I/O，如文件读取、网络请求等。

  2. 事件与回调函数
  事件的编程方式具有轻量级、松耦合、只关注事务点等优势。
  回调函数是最好的接受异步调用返回数据的方式。

  3. 单线程
  Node保持了js在浏览器中的单线程的特点。**在Node中，js与其余线程是无法共享任何状态的**。

  单线程优点：
    - 不用在意状态的问题
    - 不存在死锁的情况
    - 没有上下文交换所带来的性能上的开销

  单线程的缺点：
    - 无法利用多核CPU
    - 错误会引起整个应用退出，应用的健壮性值得考验
    - 大量计算占用CPU导致无法继续调用异步I/O

  解决方案：
    node采用了与web workers相同的思路来解决单线程中大计算量的问题——child_process（子进程）。
    通过**将计算分发给各个子进程**，将大量计算分解掉，再通过**进程之间的事件消息来传递结果**，从而很好地保持应用模型的简单和低依赖。通过master-worker的管理方式，可以很好地管理各个工作进程，以达到更高的健壮性。
  4. 跨平台
  兼容windows和*nix平台主要得益于node在架构层面的改动，它在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。libuv已成为许多系统实现跨平台的基础组件。

### Node的应用场景

  1. I/O密集型
    Node面向网络且擅长并行I/O，能够**有效地组织起更多地硬件资源，从而提供更多好的服务**。
    I/O密集地优势主要在于**Node利用事件循环的处理能力**， 而非启动每一个线程为每一个请求服务，资源占用极少。

  2. CPU密集型
    Node提供了一下两种方式来充分利用CPU
    - Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些v8不能做到性能极致地地方通过C/C++来实现。

    - 若单线程的Node不能满足需求，且用C/C++拓展后还觉得不够，可通过子进程方式，将一部分的Node进程当作常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，充分利用多CPU。

    CPU密集不可怕，合理调度是诀窍。

## 模块机制

  JS的变迁：工具类库（用于浏览器兼容）-> 组件（实现功能模块）-> 框架（功能模块组织）-> 应用（业务模块组织）

  JS被不断地类聚和抽象，以更好地组织业务逻辑，但JS先天缺乏一项功能：模块。

  在不断发展中，社区提出的Commonjs规范乃是服务端js的重要发展里程碑。

### CommonJS规范

  **【注意】现代新项目中常用[esmodule](./esModuleReadme.md)，commonjs或会逐渐被esmodule替代**。
  
  对于JS自身而言，它的规范是薄弱的，有以下缺陷：

  1. 没有模块系统；
  2. 标准库较少；（ECMAScript仅定义了部分核心库，没有文件系统，I/O流等标准API；HTML5在W3C标准化下推进发展，但仅限于浏览器端）
  3. 没有标准接口；（JS中没有定义过web服务器或者数据库之类的标准统一接口）
  4. 缺乏包管理系统；（JS应用中基本没有自动加载和安装依赖的能力）

  而CommonJs规范的提出，正是为了弥补以上所提到的缺陷。目的是**用CommonJS API写出可以具备跨宿主环境执行的能力**，这样不仅可以利用JS开发富客户端应用，还可以编写一下应用：

  1. 服务端js应用程序；
  2. 命令行工具；
  3. 桌面图形界面应用程序；
  4. 混合应用。

  CommonJS规范涵盖了：模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、web服务器网关接口、包管理等。

#### 1. CommonJS的模块规范

  CommonJS对模块的定义: 模块引入、模块定义、模块标识。

  1. 模块引入
  使用require关键字引入模块
  2. 模块定义
  在模块内使用**require**引入外部模块，
  使用**exports**对象用于导出当前模块的方法或变量，并且它是唯一导出的出口。
  模块中存在一个**module对象**，它代表模块自身。
  exports为module对象的属性。
  在node中，**一个文件就是一个模块**，将方法挂在在exports对象上作为属性即可定义导出的方式。
  3. 模块标识
  模块标识即为传递给require的参数，它必须是符合小驼峰命名的字符串，或者是以.、 ..开头的相对路径，或者绝对路径，可以省略文件名后缀.js。

    ```javascript
    var math = require('math');
    ```

模块的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。每个模块具有独立的空件，互不干扰。

### Node的模块实现

  在node中引入模块的步骤：

  1. 路径分析
  2. 文件定位
  3. 编译执行

  在node中，模块分为两类:

  1. 核心模块
  由Node提供的模块，核心模块在Node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以引入这部分核心模块时可以**省略文件定位和编译执行步骤**，并且在路径分析中优先判断，所以它的**加载速度是最快的**。
  2. 文件模块
  用户编写的模块，在运行时动态加载，需要完整的路径分析，文件定位，编译执行过程，速度比核心模块慢。

#### 优先从缓存加载

  像浏览器会缓存静态脚本文件以提高性能，**Node会对引入过的模块进行缓存**，以减少二次引入时的开销，不同于浏览器仅仅缓存文件，node缓存的是编译和执行之后的对象。

  【注意】不论核心模块还是文件模块，对于相同模块的二次加载，require方法一律采用**缓存优先的方法，这是第一优先级的**。**不同之处在于核心模块的缓存检查优先于文件模块的缓存检查**。

#### 路径分析和文件定位

- 路径分析——模块标识符

  模块标识符类型：

  1. 核心模块，如http、fs、path等
  **核心模块的优先级仅次于缓存加载。**
  注意，试图加载一个与核心模块标识符相同的自定义模块是不会成功的。

  2. .或..开始的相对路径文件模块
  require方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，使二次加载时更快。

  3. 以/开始的绝对路径文件模块
  4. 非路径形式的文件模块，如自定义的connect模块。

- 路径分析——模块路径
  模块路径是Node在定位文件模块的具体文件时指定的查找策略，具体表现为一个路径组成的数组。
  模块路径的生成规则：
  1. 当前文件目录下的node_modules目录
  2. 父目录下的node_modules目录
  3. 父目录的父目录下的node_modules目录
  4. 沿路径向上逐级递归，知道根目录下的node_modules目录
  它的生成方式和js的原型链和作用域链的查找非常相似。可以看出当前文件的路径越深，模块查找的耗时越多，因此自定义模块的加载速度时最慢的。

- 文件定位——文件扩展名分析
  require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范允许**标识符中不包含文件扩展名，这种情况下，node会按.js、.json、.node的次序扩展名，依次尝试**。在尝试过程中，需调用fs模块同步阻塞式地判断文件是否存在，为缓解node单线程阻塞式调用的缺陷，对于.node、.json文件，传递给require()时加上扩展名，又或是同步配合缓存。

- 文件定位——目录分析和包
  在分析标识符的过程中，require()通过分析文件扩展名可能会得到一个目录，此时**node会将目录当作一个包处理**。
  node包解析过程：
  1. node在当前目录下**查找package.json**，通过JSON.parse解析出包描述对象，从中提**取出main属性指定的文件名进行定位**。如果文件名缺少扩展名，则进入扩展名分析步骤。
  2. 若main指定的文件名错误，或是压根没有package.json文件，**node会将index作为默认文件名，依次查找index.js、index.json、index.node**。
  3. 在目录分析中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找，若**模块路径数组遍历完毕依旧没找到目标文件，则抛出查找失败异常**。

#### 模块编译

  编译和执行为引入文件模块的最后一个阶段，定位到具体文件后，**node会新建一个模块对象，然后根据路径载入并编译**。
  对于不同的文件扩展名，其载入方法也有所不同：

  1. .js文件。通过fs模块同步读取文件后编译执行。
  2. .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。
  3. .json文件。通过fs模块同步读取文件后，用JSON.parse()方法解析返回结果
  4. 其余扩展名文件。它们都被当做.js文件载入。

  **每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能**。

  根据不同的文件扩展名，node会调用不同的读取方式，在代码中调用require.extension可以知道系统中已有的扩展加载方式。

- js模块的编译
  在编译的过程中，**node对获取的javascript文件内容进行了头尾包装**。
  在头部添加了(function(exports, require, module, __filename, __dirname){\n，
  在尾部添加了\n}).

  这样每个模块文件之间都进行了**作用域隔离**，包装之后的代码会通过vm原生模块的**runInThisContext()方法执行**（类似eval，但具有明确上下文，不污染全局），返回具体的function对象，最后，将当前模块对象的exports属性、require()方法、module（模块对象自身）、__filename（完整文件路径）、__dirname（文件目录）**作为参数传递给这个function()执行**。

- C/C++模块的编译
  .node模块文件并不需要编译，它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程。**在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。**

- JSON文件的编译
  Node利用fs模块同步读写JSON文件的内容后，调用JSON.parse()方法得到对象，然后将它赋值给模块对象的exports，以供外部调用。

### 核心模块

#### Javascript核心模块的编译过程

  在编译所有C/C++文件之前，编译程序需要将所有的JavaScript模块文件编译为C/C++代码（非可执行代码）。

  1. 转存为C/C++代码
    node采用了V8附带的js2c.py工具，将所有内置的javascript代码（src/node.js和lib/*.js）转化为C++里的数组，生成node_natives.h头文件。

  2. 编译javascript核心模块
    引入核心模块的过程中也经历**头尾包装**的过程，与文件模块区别在于：
    js核心模块获取源代码的方式是从内存中加载的，其源文件通过process.binding('natives')取出，编译成功的核心模块缓存到NativeModule_cache上，
    文件模块则缓存到Module._cache。

#### C/C++核心模块的编译过程

  核心模块中，有些模块全由C/C++编写；有些则**由C/C++完成核心部分（主内），其他部分则由JavaScript实现包装或向外导出（主外）**，这种封装模式是Node能够**提高性能**的常见方式。

  因为通常，脚本语言（js）的开发速度由于静态语言（C/C++），但其性能弱于静态语言，**node这种复合模式可以在开发速度与性能之间找到平衡点**。

  由纯C/C++编写的部分统一成为**内建模块**。Node中的buffer、crypto、 evals、 fs、 os等模块都是部分通过C/C++编写的。